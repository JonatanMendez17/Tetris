<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris Moderno</title>
  <style>
    :root{
      --bg:#0f1724;
      --panel:#0b1220;
      --accent:#7c5cff;
      --muted:#9aa4b2;
      --tile-size:28px;
      --board-w:10;
      --board-h:20;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{background:linear-gradient(180deg,var(--bg),#071021);color:#dbe7f2;display:flex;align-items:center;justify-content:center;padding:20px}
    .wrap{display:grid;grid-template-columns:1fr 300px;gap:20px;align-items:start;max-width:1100px;width:100%}
    .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 6px 18px rgba(2,6,23,0.6);}

    /* Game area */
    .game{display:flex;gap:16px;align-items:flex-start}
    canvas{background:linear-gradient(180deg, #071328 40%, #04101d);border-radius:8px;padding:8px}

    /* Right panel */
    .panel{width:100%;}
    .panel .section{margin-bottom:12px}
    h1{font-size:20px;margin:0 0 6px 0}
    .stats{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .stat{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;text-align:center}
    .muted{color:var(--muted);font-size:13px}

    /* Next/hold previews */
    .preview{display:flex;gap:12px;flex-direction:column}
    .preview .box{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));padding:8px;border-radius:8px;min-height:120px}

    /* Controls */
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:8px}
    .controls button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:10px;border-radius:8px;color:inherit;cursor:pointer}
    .controls .primary{background:linear-gradient(90deg,var(--accent),#5bf3ff);color:#021;box-shadow:0 6px 14px rgba(124,92,255,0.12);border:none}

    footer{font-size:12px;color:var(--muted);margin-top:6px}

    /* Mobile responsiveness */
    @media (max-width:900px){
      .wrap{grid-template-columns:1fr;}
      .panel{order:2}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card game">
      <canvas id="board" width="280" height="560"></canvas>
      <div style="display:flex;flex-direction:column;gap:8px;width:220px">
        <div class="preview box card" id="holdBox">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Hold</strong>
            <span class="muted">Tecla: Shift</span>
          </div>
          <div id="holdCanvasHolder" style="display:flex;justify-content:center;padding-top:8px"></div>
        </div>

        <div class="preview card box">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <strong>Next</strong>
            <span class="muted">Cola de 5</span>
          </div>
          <div id="nextList" style="display:flex;flex-direction:column;gap:6px;padding-top:8px"></div>
        </div>

      </div>
    </div>

    <div class="panel card">
      <h1>Tetris Moderno</h1>
      <p class="muted">Versión en HTML, CSS y JavaScript — Compatible móviles y escritorio.</p>

      <div class="section stats">
        <div class="stat"><div class="muted">Puntos</div><div id="score">0</div></div>
        <div class="stat"><div class="muted">Nivel</div><div id="level">0</div></div>
        <div class="stat"><div class="muted">Líneas</div><div id="lines">0</div></div>
        <div class="stat"><div class="muted">Record</div><div id="best">0</div></div>
      </div>

      <div class="section">
        <div class="controls">
          <button id="startBtn" class="primary">Iniciar / Reanudar</button>
          <button id="pauseBtn">Pausa</button>
          <button id="restartBtn">Reiniciar</button>
          <button id="muteBtn">Silenciar</button>
        </div>
        <footer>Controles: ← → bajar (↓) rotar (X / ↑) hold (Shift) drop duro (Space)</footer>
      </div>

      <div class="section">
        <h3 class="muted">Controles táctiles</h3>
        <p class="muted">En móviles, toca a la izquierda/derecha para mover, desliza hacia abajo para "soft drop" y hacia abajo rápido para "hard drop". Doble toque para rotar.</p>
      </div>

    </div>
  </div>

  <script>
  // Tetris Moderno - Vanilla JS
  (()=>{
    const COLS=10, ROWS=20, TILE=28;
    const canvas=document.getElementById('board');
    const ctx=canvas.getContext('2d');
    canvas.width=COLS*TILE;
    canvas.height=ROWS*TILE;
    ctx.scale(1,1);

    // small canvases for hold and next
    function makePreviewCanvas(w=4,h=4){
      const c=document.createElement('canvas');
      c.width=w*TILE; c.height=h*TILE; c.style.width=(w*12)+'px'; c.style.height=(h*12)+'px';
      return c;
    }
    const holdHolder=document.getElementById('holdCanvasHolder');
    const holdCanvas=makePreviewCanvas(4,4); holdHolder.appendChild(holdCanvas);
    const holdCtx=holdCanvas.getContext('2d');

    const nextList=document.getElementById('nextList');

    // Score elements
    const scoreEl=document.getElementById('score');
    const levelEl=document.getElementById('level');
    const linesEl=document.getElementById('lines');
    const bestEl=document.getElementById('best');

    const startBtn=document.getElementById('startBtn');
    const pauseBtn=document.getElementById('pauseBtn');
    const restartBtn=document.getElementById('restartBtn');
    const muteBtn=document.getElementById('muteBtn');

    let audioEnabled=true;
    muteBtn.onclick=()=>{audioEnabled=!audioEnabled; muteBtn.textContent= audioEnabled? 'Silenciar' : 'Activar Sonido';}

    // pieces (T, J, L, Z, S, I, O)
    const SHAPES = {
      I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      J: [[1,0,0],[1,1,1],[0,0,0]],
      L: [[0,0,1],[1,1,1],[0,0,0]],
      O: [[1,1],[1,1]],
      S: [[0,1,1],[1,1,0],[0,0,0]],
      Z: [[1,1,0],[0,1,1],[0,0,0]],
      T: [[0,1,0],[1,1,1],[0,0,0]]
    };
    const COLORS = {I:'#5bf3ff', J:'#555bff', L:'#ffb86b', O:'#ffd166', S:'#7cff8f', Z:'#ff6b6b', T:'#c892ff'};

    function rotate(matrix){
      const N=matrix.length; const res=Array.from({length:N},()=>Array(N).fill(0));
      for(let r=0;r<N;r++) for(let c=0;c<N;c++) res[c][N-1-r]=matrix[r][c];
      return res;
    }

    // Create empty board
    function createBoard(){
      return Array.from({length:ROWS},()=>Array(COLS).fill(null));
    }

    // Random bag generator
    function bagGenerator(){
      const bag=['I','J','L','O','S','Z','T'];
      for(let i=bag.length-1;i>0;i--){
        const j=Math.floor(Math.random()*(i+1)); [bag[i],bag[j]]=[bag[j],bag[i]];
      }
      return bag;
    }

    // Game state
    let board=createBoard();
    let current=null;
    let nextQueue=[]; let bag=[];
    let hold=null; let holdLocked=false;
    let score=0, level=0, lines=0, best= localStorage.getItem('tetris_best')||0;
    bestEl.textContent=best;
    let dropInterval=1000; let dropTimer=0; let lastTime=0; let running=false; let paused=false;

    // Audio (simple beeps)
    const audioCtx=new (window.AudioContext||window.webkitAudioContext)();
    function beep(freq=440,duration=0.06,vol=0.06){
      if(!audioEnabled) return;
      const o=audioCtx.createOscillator(); const g=audioCtx.createGain();
      o.type='sine'; o.frequency.value=freq; g.gain.value=vol;
      o.connect(g); g.connect(audioCtx.destination);
      o.start(); o.stop(audioCtx.currentTime+duration);
    }

    function newPiece(type){
      const shape=SHAPES[type];
      // normalize to square matrix
      const size=Math.max(shape.length, shape[0].length);
      const matrix=Array.from({length:size},(_,r)=>Array.from({length:size},(_,c)=> (shape[r] && shape[r][c])? 1:0));
      return {type, matrix, x: Math.floor((COLS-size)/2), y: -1};
    }

    function spawn(){
      if(nextQueue.length<7) refillBag();
      current=newPiece(nextQueue.shift());
      holdLocked=false;
      if(collision(current.matrix,current.x,current.y)){
        // game over
        running=false; paused=false;
        beep(120,0.4,0.2);
        alert('Game Over! Puntuación: '+score);
        if(score>best){ localStorage.setItem('tetris_best',score); best=score; bestEl.textContent=best; }
      }
    }

    function refillBag(){
      if(bag.length===0) bag=bagGenerator();
      while(nextQueue.length<7) nextQueue.push(...bag.splice(0,bag.length));
      // ensure queue has at least 5 visible nexts
      updateNextDisplay();
    }

    function updateNextDisplay(){
      nextList.innerHTML='';
      for(let i=0;i<5;i++){
        const type=nextQueue[i]||'';
        const box=document.createElement('div'); box.style.display='flex'; box.style.alignItems='center';
        box.style.height='36px'; box.style.padding='6px'; box.style.borderRadius='6px';
        box.textContent=' ';
        const c=document.createElement('canvas'); c.width=4*TILE; c.height=2*TILE; c.style.width='100%'; c.style.height='36px';
        const ct=c.getContext('2d'); ct.clearRect(0,0,c.width,c.height);
        if(type){ drawMiniPiece(ct,type,c.width,c.height); }
        box.appendChild(c);
        nextList.appendChild(box);
      }
    }

    function drawMiniPiece(ctx,type,w,h){
      ctx.save(); ctx.scale(1,1); ctx.clearRect(0,0,w,h);
      const shape=SHAPES[type]; const cols=shape[0].length, rows=shape.length; const s=Math.min(w/cols,h/rows);
      const offx=(w - cols*s)/2, offy=(h - rows*s)/2;
      for(let r=0;r<rows;r++) for(let c=0;c<cols;c++) if(shape[r][c]){
        ctx.fillStyle=COLORS[type]; ctx.fillRect(offx+c*s+2, offy+r*s+2, s-4, s-4);
      }
      ctx.restore();
    }

    function draw(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      // draw board blocks
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const cell=board[r][c];
        if(cell){ drawCell(ctx,c*TILE,r*TILE,TILE,cell); }
        // grid subtle
        ctx.strokeStyle='rgba(255,255,255,0.02)'; ctx.strokeRect(c*TILE, r*TILE, TILE, TILE);
      }
      if(current){
        // ghost
        const ghostY=findGhostY();
        drawPiece(ctx,current.matrix,current.x,ghostY,true);
        // piece
        drawPiece(ctx,current.matrix,current.x,current.y,false);
      }
    }

    function drawCell(ctx,x,y,size,color){
      ctx.fillStyle=color; ctx.fillRect(x+1,y+1,size-2,size-2);
      ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.strokeRect(x+1,y+1,size-2,size-2);
    }

    function drawPiece(ctx,matrix,px,py,ghost=false){
      for(let r=0;r<matrix.length;r++){
        for(let c=0;c<matrix[r].length;c++){
          if(matrix[r][c]){
            const x=(px+c)*TILE; const y=(py+r)*TILE;
            if(y>=0){
              ctx.globalAlpha = ghost?0.18:1;
              drawCell(ctx,x,y,TILE,COLORS[current.type]);
              ctx.globalAlpha = 1;
            }
          }
        }
      }
    }

    function findGhostY(){
      let y=current.y;
      while(!collision(current.matrix,current.x,y+1)) y++;
      return y;
    }

    function collision(matrix,px,py){
      for(let r=0;r<matrix.length;r++) for(let c=0;c<matrix[r].length;c++){
        if(matrix[r][c]){
          const x=px+c, y=py+r;
          if(x<0||x>=COLS||y>=ROWS) return true;
          if(y>=0 && board[y][x]) return true;
        }
      }
      return false;
    }

    function lockPiece(){
      const m=current.matrix; for(let r=0;r<m.length;r++) for(let c=0;c<m[r].length;c++) if(m[r][c]){
        const x=current.x+c, y=current.y+r;
        if(y>=0) board[y][x]=COLORS[current.type];
      }
      clearLines();
      spawn();
    }

    function clearLines(){
      let cleared=0;
      outer: for(let r=ROWS-1;r>=0;r--){
        for(let c=0;c<COLS;c++) if(!board[r][c]) continue outer;
        // full
        board.splice(r,1); board.unshift(Array(COLS).fill(null)); cleared++; r++; // recheck same row index
      }
      if(cleared>0){
        // scoring
        const pointsMap={1:40,2:100,3:300,4:1200};
        score += (pointsMap[cleared]||0)*(level+1);
        lines += cleared;
        // level up every 10 lines
        const newLevel=Math.floor(lines/10);
        if(newLevel>level){ level=newLevel; dropInterval = Math.max(80, 1000 - level*80); beep(800,0.08,0.06); }
        scoreEl.textContent=score; levelEl.textContent=level; linesEl.textContent=lines;
        if(score>best){ best=score; bestEl.textContent=best; localStorage.setItem('tetris_best',best); }
      }
    }

    // movement and rotation with simple wall-kick
    function move(dir){
      if(!current) return; current.x += dir; if(collision(current.matrix,current.x,current.y)) current.x -= dir; else beep(700,0.02,0.02);
    }
    function softDrop(){ if(!current) return; if(!collision(current.matrix,current.x,current.y+1)) current.y++; else { lockPiece(); } }
    function hardDrop(){ if(!current) return; while(!collision(current.matrix,current.x,current.y+1)) current.y++; lockPiece(); score += 2*(level+1); scoreEl.textContent=score; beep(1200,0.04,0.06); }

    function rotateCurrent(){ if(!current) return; const origX=current.x, origMatrix=current.matrix; const rotated=rotate(origMatrix); let kicked=false;
      const kicks=[0,1,-1,2,-2];
      for(const k of kicks){ current.matrix=rotated; current.x=origX+k; if(!collision(current.matrix,current.x,current.y)){ kicked=true; break; } }
      if(!kicked){ current.matrix=origMatrix; current.x=origX; } else beep(900,0.02,0.04);
    }

    function holdPiece(){ if(!current) return; if(holdLocked) return; if(!hold){ hold=current.type; spawn(); } else { const old=hold; hold=current.type; current=newPiece(old); current.y=0; }
      holdLocked=true; drawHold(); beep(600,0.02,0.04);
    }

    function drawHold(){ holdCtx.clearRect(0,0,holdCanvas.width,holdCanvas.height); if(!hold) return; drawMiniPiece(holdCtx,hold,holdCanvas.width,holdCanvas.height); }

    // input
    const keys={
      ArrowLeft:()=>move(-1), ArrowRight:()=>move(1), ArrowDown:()=>softDrop(),
      ArrowUp:()=>rotateCurrent(), KeyX:()=>rotateCurrent(), Space:()=>hardDrop(), ShiftLeft:()=>holdPiece(), ShiftRight:()=>holdPiece(),
    };

    document.addEventListener('keydown',(e)=>{
      if(!running) return;
      const fn=keys[e.code]; if(fn){ e.preventDefault(); fn(); }
    });

    // touch controls (simple)
    let touchStartX=0, touchStartY=0, touchStartTime=0;
    canvas.addEventListener('touchstart', (e)=>{
      if(!running) return; const t=e.touches[0]; touchStartX=t.clientX; touchStartY=t.clientY; touchStartTime=Date.now();
    },{passive:true});
    canvas.addEventListener('touchend',(e)=>{
      if(!running) return; const dt=Date.now()-touchStartTime; const touch=e.changedTouches[0]; const dx=touch.clientX-touchStartX, dy=touch.clientY-touchStartY;
      if(Math.abs(dx)>40 && Math.abs(dx)>Math.abs(dy)){ if(dx>0) move(1); else move(-1); }
      else if(Math.abs(dy)>40 && Math.abs(dy)>Math.abs(dx)){
        if(dy>0) hardDrop(); else softDrop();
      } else {
        // tap or double tap detection
        if(dt<200) rotateCurrent(); else softDrop();
      }
    });

    // buttons
    startBtn.onclick=()=>{ if(!running) start(); else paused=false; }
    pauseBtn.onclick=()=>{ paused=!paused; }
    restartBtn.onclick=()=>{ reset(); start(); }

    function start(){ if(running) return; if(audioCtx.state==='suspended') audioCtx.resume(); running=true; paused=false; lastTime=performance.now(); if(!current) spawn(); requestAnimationFrame(loop); }
    function reset(){ board=createBoard(); current=null; bag=[]; nextQueue=[]; refillBag(); hold=null; holdLocked=false; score=0; level=0; lines=0; dropInterval=1000; scoreEl.textContent=score; levelEl.textContent=level; linesEl.textContent=lines; drawHold(); updateNextDisplay(); }

    function loop(ts){ if(!running) return; if(paused){ lastTime=ts; requestAnimationFrame(loop); return; }
      const delta=ts-lastTime; lastTime=ts; dropTimer += delta;
      if(dropTimer>dropInterval){ dropTimer=0; if(current){ if(!collision(current.matrix,current.x,current.y+1)) current.y++; else lockPiece(); } }
      draw(); requestAnimationFrame(loop);
    }

    // initialize
    reset(); draw();

  })();
  </script>
</body>
</html>
